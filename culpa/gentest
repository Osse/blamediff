#!/bin/sh

exec >"tests/$1.rs"

cat <<'EOF'
// Generated by gentest

use culpa::*;
use pretty_assertions::assert_eq;
use std::path::Path;

const FILE: &str = "lorem-ipsum.txt";

// Return list of strings in the format "SHA1 SP <line contents>"
fn run_git_blame(revision: &str) -> Vec<String> {
    let output = std::process::Command::new("git")
        .args(["-C", "..", "blame", "--line-porcelain", revision, FILE])
        .output()
        .expect("able to run git blame")
        .stdout;

    let output = std::str::from_utf8(&output).expect("valid UTF-8");

    output
        .split_terminator('\n')
        .collect::<Vec<_>>()
        .chunks(13)
        .map(|c| {
            format!(
                "{} {} {}",
                &c[0][..40],
                c[10].starts_with("boundary"),
                &c[12][1..]
            )
        })
        .collect()
}

fn compare(range: &str, blame: Vec<BlamedLine>, fasit: Vec<String>) {
    let sha1 = range.find('.').map(|p| &range[p + 2..]).unwrap_or(range);
    let blob = sha1.to_string() + ":" + FILE;

    let output = std::process::Command::new("git")
        .args(["show", &blob])
        .output()
        .expect("able to run git show")
        .stdout;

    let contents = std::str::from_utf8(&output).expect("valid UTF-8");

    // Create a Vec of Strings similar to the one obtained from git itself.
    // This with pretty assertions makes it much more pleasant to debug
    let blame: Vec<String> = blame
        .into_iter()
        .zip(contents.lines())
        .map(|(bl, line)| format!("{} {} {}", bl.id.to_string(), bl.boundary, line))
        .collect();

    assert_eq!(fasit, blame);
}

macro_rules! blame_test {
    ($test_name:ident, $range:literal) => {
        #[test]
        fn $test_name() {
            let r = gix::discover(".").unwrap();
            let blame = culpa::blame_file(&r, $range, &Path::new(FILE)).unwrap();
            let fasit = run_git_blame($range);
            compare($range, blame.blamed_lines(), fasit);
        }
    };
}
EOF

git log --reverse --format='%h%x09%s' "$1" | awk -vtest="$1" -F'\t' '
BEGIN {
    sub(/-/, "_", test)
}
{
    printf("// %s: %s\nblame_test!(%s_%02d, \"%s\");\n", $1, $2, test, NR, $1);
    for (i in hashes) {
        printf("blame_test!(%s_%02d_%02d, \"%s..%s\");\n", test, NR, i, hashes[i], $1);
    }
    printf("\n")
    hashes[NR] = $1
}
'
